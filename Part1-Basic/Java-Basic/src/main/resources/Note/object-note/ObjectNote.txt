类：构造对象的模板和蓝图
类构造对象的过程叫创建实例
封装：数据的隐藏，数据---实例域，操纵数据过程 --- 方法
对于每个类对象都有自己特定的实例域，这些值的集合代表当前对象的状态

oop三大特征
对象行为
对象状态
对象标识
OOP设置理念：高内聚，低耦合
use-a 依赖
has-a 聚合
is-a 继承

构造器的特征和作用：
初始化实例域
构造器与类同名
一个类可有>=1个构造器
构造器没有返回值
总是伴随着new一起调用

fianalize通知GC回收，1.8以后废弃了

OOP设计思路
1.保证数据私有化
2.一定要对数据初始化
3.不要再类中使用过多的基本数据类型
4.不是所有的域都需要独立的域访问器和域更改器
5.将职责过多的类进行分解,单一责任原则
6.类名和方法名见名知义
7.优先使用不可变的类（线程安全考虑）


封装:数据私有化
继承:java中只存在单继承,但不限于一个层次
多态:可以将子类对象赋值给父类对象的过程,即奔雷对象既可引用本类对象,又可以引用子类的对象


方法调用：会有一个方法表
C x = new C();
x.f(args)
1.编译器查看对象的声明类型和方法名，列举所有名为f(xxx)的方法，和父类中的f(xxx)方法(父类私有方法除外)
2.根据参数类型，寻找匹配的方法
3.private static final方法，构造器 编译器能够准确知道调用谁的方法---静态绑定
  调用方法依赖于隐式参数的实际调用类型，在运行时实现动态绑定
4.动态绑定JVM会议最优策略执行： D x = new D(); x.f(String); C是D的父类,如果在D中存在相应方法则直接
调用，否则才会到父类中寻找

抽象：自上而下的类继承中，越上层的类越具有通用性，因此会更加抽象
抽象类
抽象类中至少包含一个抽象方法
抽象方法中可以包含具体的方法
抽象方法充当着占位的角色，在子类中实现
抽象类中定义部分抽象方法或者不定义抽象方法，则子类也必须是抽象类
如果定义全部的抽象方法，子类则不是抽象类
抽象类不能被实例化 new A();如果B是A的子类 A a c= new B()可行

访问修饰符
private --- 仅本类可见
default --- 本包本类可见
protected --- 本包 本类 子类可见
public --- 所有位置可见

Object
1.equals()
具备的特性
自反性:任意非空引用x x.equals(x) == true
对称性:x.equals(y) == true then y.equals(x) == true
传递性: x.equals(y) == true,y.equals(z) == true then x.equals(z)
任意非空x引用,x.equals(null) == false
其他:如果子类有自己的相等概念，则对称性需要用getClass()检查
     如果父类决定相等性,则用instanceof判断即可

反射 --- 走后门
运行时分析类的能力
运行时查看对象
实现通用的数组操作代码
利用Method

接口:
一个类可实现多个接口
接口不是类，而是对类的需求的描述，类要遵循接口规范定义
把类声明为一个实现特定接口的形式
对接口中的方法进行定义
接口中的方法默认public
接口中不能有实例域和可以有常量（1.8）静态方法（Path）和默认方法（Collection）
接口间的继承机制是多继承

默认方法冲突问题
A接口有默认方法default m(),再父类或者另一个接口中同样定义了default m()
1.如果父类提供了实现，则父类优先
2.如果父接口提供了一个默认方法，子接口也存在一个相同的默认方法，接口冲突通过重写解决


接口与抽象类
解决单继承的问题,降低多继承的复杂性，接口可作为基类的辅助

接口和回调
特定事件发生，采取特定的动作

对象拷贝
Clone
深拷贝和浅拷贝
当对象是不可变时，用浅拷贝即可
对象通常是可变的则需要深拷贝
拷贝判断
1.默认的clone是否满足要求
2.是否可以在可变的子对象上调用clone来修补默认的clone方法
3.是否不该使用clone
类必须：
1.实现Cloneable接口
2.重新定义clone方法，并指定public修饰符



内部类
定义在另一个类中的类
为什么使用内部类？
内部类方法可以访问该类定义所在的作用域的数据，包括私有数据
内部类可以对同一个包的其他类隐藏
定义回调函数可以使用匿名内部类

代理:运行时创建一个实现给定接口的新类

异常
check 编译器会检查是否提供了异常处理
uncheck null引用等，编译器不进行检测的异常
需要抛出异常的几种情况
1.抛出一个受检查异常
2.运行过程中出现地错误throw
3.程序出错，uncheck异常
4.JVM和运行时库出错误

捕获异常
try{}catch(){}finally{}
执行try{}语句块，如果有异常则执行catch{}捕获,finally{}最后执行
finally语句的执行情况
try{
//1
//may throw exception
2
}catch(Exception e){
3
//error msg
4
}finally{
5
//close resources
}
6
1.代码没有抛出异常，执行顺序1256
2.抛出异常catch捕获，执行顺序13456
如果catch子句抛出异常，异常抛回给方法调用者，执行顺序135
3.抛出异常不是由catch捕获，执行循序15

注意：finally中的return.如果try中同时有return,那么finally中的return会覆盖try中的return

带资源的try
try(Resource res = ...){
}

异常机制的技巧
1.异常处理不能代替简单测试
2.不要过分细化异常
3.利用异常层次结构
4.不要压制异常
5.检查错误时，苛刻比放任好
6.不羞于传递异常

断言：假设确信某个属性符合要求，并且代码执行依赖这个属性
使用情况
断言失败时致命的，不可恢复的错误
只能用于开发测试阶段
日志:Logger

三种处理系统错误的机制

泛型类设计：增加复用性
1.泛型类
class A<T>{
}
2.泛型方法
public static <T> T method(T... t){
}
3.类型变量的限定
类型变量限定
保证有compareTo方法
<T extends Comparable>
通配符
<? extends A>
<? super B>
---------
Pair<?>
可以行
Object.setObject()
setFirst(null)
超类限定通配符可向泛型对象写入
子类限定通配符可从泛型对象读取

继承设计技巧
1.将公共操作和域放在父类
2.不要使用protected
3.在is-a关系的时候再使用继承
4.除非所有的方法都有意义，否则不要使用继承
5.重写方法时，不要改变预期行为
6.使用多态而非类信息
7.不要滥用反射
继承的问题：单继承

集合
Collection

Iterator
删除第一个元素
it.next()//跳过第一个元素
it.remove()
删除相邻元素
it.remove()
it.next()
it.remove()